import { supabase } from './supabaseClient'
import { nanoid } from 'nanoid'

export async function fetchTeams() {
  try {
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) throw new Error('No authenticated user')

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    let teamsQuery = supabase.from('teams').select(`
      *,
      team_members (
        id,
        user_id,
        role
      ),
      profiles!created_by_profile (
        full_name
      )
    `)

    // If not admin, filter teams where user is a member
    if (profile?.role !== 'admin') {
      const { data: memberTeams, error: memberError } = await supabase
        .from('team_members')
        .select('team_id')
        .eq('user_id', user.id)

      if (memberError) throw memberError

      const teamIds = memberTeams.map(mt => mt.team_id)
      teamsQuery = teamsQuery.in('id', teamIds)
    }

    // Execute the final query
    const { data: teams, error } = await teamsQuery.order('created_at', { ascending: false })
    if (error) throw error

    // Get member profiles in a separate query
    const memberIds = teams.flatMap(team => 
      team.team_members.map(member => member.user_id)
    )

    const { data: memberProfiles } = await supabase
      .from('profiles')
      .select('id, full_name')
      .in('id', memberIds)

    const profileMap = new Map(
      memberProfiles?.map(profile => [profile.id, profile]) || []
    )

    // Transform the data
    return teams.map(team => ({
      ...team,
      createdBy: team.profiles?.full_name || 'Unknown',
      memberCount: team.team_members?.length || 0,
      members: team.team_members?.map(member => ({
        id: member.user_id,
        name: profileMap.get(member.user_id)?.full_name || 'Unknown',
        role: member.role
      })) || [],
      ticketCount: 0 // We'll implement this later
    }))
  } catch (error) {
    console.error('Error fetching teams:', error)
    throw error
  }
}

export async function createTeam({ name, description }) {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  // Create the team
  const { data, error } = await supabase
    .from('teams')
    .insert({
      name,
      description,
      created_by: user.id,
      created_by_profile: user.id
    })
    .select()
    .single()

  if (error) throw error

  // Add the creator as a team member
  const { error: memberError } = await supabase
    .from('team_members')
    .insert({
      team_id: data.id,
      user_id: user.id,
      role: 'owner'
    })

  if (memberError) throw memberError

  return data
}

export async function updateTeam({ id, name, description }) {
  try {
    const { data, error } = await supabase
      .from('teams')
      .update({ name, description })
      .eq('id', id)
      .select()
      .single()

    if (error) throw error
    return data
  } catch (error) {
    console.error('Error updating team:', error)
    throw error
  }
}

export async function deleteTeam(id) {
  try {
    const { error } = await supabase
      .from('teams')
      .delete()
      .eq('id', id)

    if (error) throw error
  } catch (error) {
    console.error('Error deleting team:', error)
    throw error
  }
}

export async function addTeamMember({ teamId, userId }) {
  try {
    const { data, error } = await supabase
      .from('team_members')
      .insert([{ team_id: teamId, user_id: userId }])
      .select()
      .single()

    if (error) throw error
    return data
  } catch (error) {
    console.error('Error adding team member:', error)
    throw error
  }
}

export async function removeTeamMember(teamId, userId) {
  const { error } = await supabase
    .from('team_members')
    .delete()
    .match({ team_id: teamId, user_id: userId })

  if (error) {
    console.error('Error removing team member:', error)
    throw new Error('Failed to remove team member')
  }
}

export async function generateTeamInvite(teamId) {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  const expiresAt = new Date(Date.now() + 5 * 60 * 1000) // 5 minutes from now

  const { data, error } = await supabase
    .from('team_invites')
    .insert({
      team_id: teamId,
      created_by: user.id,
      expires_at: expiresAt.toISOString()
      // code will be auto-generated by the default value
    })
    .select('code')
    .single()

  if (error) throw error
  return data.code
}

export async function joinTeamByInviteCode(code) {
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('Not authenticated')

  // Find the valid invite
  const { data: invite, error: inviteError } = await supabase
    .from('team_invites')
    .select('*')
    .eq('code', code)
    .is('used_at', null)
    .single()

  if (inviteError || !invite) {
    throw new Error('Invalid invite code')
  }

  // Check if expired
  if (new Date(invite.expires_at) < new Date()) {
    throw new Error('Invite code has expired')
  }

  // Check if already a member
  const { data: existingMember, error: memberCheckError } = await supabase
    .from('team_members')
    .select('id')
    .eq('team_id', invite.team_id)
    .eq('user_id', user.id)
    .single()

  if (existingMember) {
    throw new Error('You are already a member of this team')
  }

  // Add user to team
  const { error: joinError } = await supabase
    .from('team_members')
    .insert({
      team_id: invite.team_id,
      user_id: user.id,
      role: 'member'
    })

  if (joinError) {
    throw new Error('Failed to join team')
  }

  // Mark invite as used
  const { error: updateError } = await supabase
    .from('team_invites')
    .update({
      used_at: new Date().toISOString(),
      used_by: user.id
    })
    .eq('code', code)

  if (updateError) {
    // If we fail to mark as used, still consider the join successful
    console.error('Failed to mark invite as used:', updateError)
  }

  return { success: true, team_id: invite.team_id }
} 